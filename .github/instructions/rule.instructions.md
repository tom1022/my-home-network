---
applyTo: '**'
---
# 1. 構文とベストプラクティス
- ansible-lintのルールを厳守し、警告が出ないコードを生成すること。
- モジュールはFQN（例: ansible.builtin.copy）で記述すること。
- 可能な限り専用モジュール（apt, service, template等）を使用し、shell/commandは最終手段とすること。
- フォールバックは決して実装しないこと。
- Ansibleでの自動化が適切でない場合は、その理由を明確に説明し、手動操作を指示すること。

# 2. べき等性と信頼性
- すべてのタスクでべき等性を担保すること。
- shell/commandを使用せざるを得ない場合は、必ず changed_when と failed_when を適切に設定すること。
- タイムアウトが発生しうる操作には、asyncとpollによる非同期処理を検討すること。

# 3. 設計と責務分離
- ロジック（tasks）と変数（vars/defaults）を分離し、ハードコードを避けること。
- パスワードや鍵などの機密情報は、Ansible Vaultや外部シークレット管理を想定した変数構成にすること。
- 処理が複雑になる場合は、Playbook単体ではなくRole構造（tasks, vars, templates）への分割を提案すること。

# 4. エラー対応と論理的判断
- 技術的制約でAnsibleによる自動化が不可能な場合、または非常に不安定になる場合は、その理由を論理的に説明し、無理にコード化しないこと。
- 手作業を指示する場合は、OSやミドルウェアの仕様に基づいた具体的な根拠を示すこと。
- Playbook内で同様のパターンが繰り返されている場合、共通化（loopやinclude_tasks）を検討すること。

# 現状調査と情報収集の徹底
- ターゲット環境の構成（ディスクのパス、OSのバージョン、既存の設定等）が不明確なまま実装を進めないこと。
- 必要な情報が不足している場合は、実装コードを生成する前に、まず情報収集のための調査用コマンド（ansible -m setup, lsblk, blkid 等）を提示し、ユーザーにその実行結果を求めること。
- 調査結果に基づき、環境の差異（例：デバイス名が /dev/sdb か /dev/vdb か）を吸収できる動的なコードを設計すること。
